<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>动态规划 | Echin の 博客</title><meta name="author" content="Echin-h"><meta name="copyright" content="Echin-h"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="动态规划 动态规划，简称DP，是解决很多重叠子问题的有效方法 每一个状态是由上一个状态推导出来的 动态规划与贪心算法  动规是由前一个状态推导出来的，而贪心是局部直接选最优的  思路  确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  斐波那契数列1 1 2 3 5…….. 递归 123456func fib(n int) int">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://example.com/2024/05/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Echin の 博客">
<meta property="og:description" content="动态规划 动态规划，简称DP，是解决很多重叠子问题的有效方法 每一个状态是由上一个状态推导出来的 动态规划与贪心算法  动规是由前一个状态推导出来的，而贪心是局部直接选最优的  思路  确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  斐波那契数列1 1 2 3 5…….. 递归 123456func fib(n int) int">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg">
<meta property="article:published_time" content="2024-05-06T02:00:52.000Z">
<meta property="article:modified_time" content="2024-05-23T12:37:36.809Z">
<meta property="article:author" content="Echin-h">
<meta property="article:tag" content="代码随想录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg"><link rel="shortcut icon" href="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg"><link rel="canonical" href="http://example.com/2024/05/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"TQQRJ72W3Y","apiKey":"691b279e3e99ecf664b63c47582168b7","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Echin-h","link":"链接: ","source":"来源: Echin の 博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态规划',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-23 20:37:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">115</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Echin の 博客"><span class="site-name">Echin の 博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-06T02:00:52.000Z" title="发表于 2024-05-06 10:00:52">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-23T12:37:36.809Z" title="更新于 2024-05-23 20:37:36">2024-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="动态规划"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><hr>
<p>动态规划，简称<strong>DP</strong>，是解决很多重叠子问题的有效方法</p>
<p>每一个状态是由上一个状态推导出来的</p>
<p><strong>动态规划与贪心算法</strong></p>
<blockquote>
<p>动规是由前一个状态推导出来的，而贪心是局部直接选最优的</p>
</blockquote>
<p><strong>思路</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>1 1 2 3 5……..</p>
<p><strong>递归</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间O(n) 空间O(1)</span></span><br><span class="line">    </span><br><span class="line">    pre2 := <span class="number">0</span></span><br><span class="line">    pre1 := <span class="number">1</span></span><br><span class="line">    curr := pre1 + pre2 <span class="comment">//第i个数等于i-1个和i-2个数的和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;=n; i++&#123;</span><br><span class="line">        curr = pre1 + pre2</span><br><span class="line">        pre2 = pre1 <span class="comment">//更新变量,实现向右移动</span></span><br><span class="line">        pre1 = curr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p> <strong>思路</strong></p>
<p>有规律，第一层为1，第二层为2，第三层为1+2&#x3D;3，第四层为2+3&#x3D;5</p>
<p>由此一来，就是上面一题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">3</span>; i &lt; n+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用最小会用爬楼梯"><a href="#使用最小会用爬楼梯" class="headerlink" title="使用最小会用爬楼梯"></a>使用最小会用爬楼梯</h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>从第i层开始起跳需要花费cost[i]的费用</li>
<li>最终要跳到cost[n]层，也就是最顶层，没有费用标注</li>
<li>可以从n&#x3D;0,1出发</li>
</ul>
<p>下面设置一个dp数组，表示<strong>到达每一层需要的费用</strong></p>
<p>而每一层的费用是 <strong>上一层的起跳费用cost[i-1]&#x2F;cost[i-2]+上一层的到达上一层需要的费用dp[i-1]&#x2F;dp[i-2]</strong></p>
<p>因此 <strong>dp[i] &#x3D; min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span> , <span class="built_in">len</span>(cost)+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>],dp[<span class="number">1</span>] = <span class="number">0</span> , <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">2</span> ;i&lt;= <span class="built_in">len</span>(cost); i++&#123;</span><br><span class="line">		dp[i] = min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(cost)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>思路</strong></p>
<p>其实我一开始想到的是回溯并写出了回溯的代码，然后超时了，唉。</p>
<p>那就用动态规划来写把，其实脑子想着动态规划，但是一点思路都没有，就看了代码随想录，感觉最重要的是 dp数组的确定以及index的含义</p>
<ul>
<li><p><strong>dp数组的确定以及index的含义</strong></p>
<p>因为要求路径不如把dp数组的值当作到达 i,j的路径数</p>
<p>又因为robot只能向下，向右行驶，因此第一行和第一列都只有一条路径，最后实现</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png" alt="62.不同路径1"></p>
</li>
</ul>
<p>ok，然后后面就很简单了</p>
<p><strong>动态规划</strong></p>
<p>我这样子写最清楚，有更加简便的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回溯</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> x == m<span class="number">-1</span> &amp;&amp; y == n<span class="number">-1</span> &#123;</span><br><span class="line">			count++</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> x &lt; m<span class="number">-1</span> &#123;</span><br><span class="line">			dfs(x+<span class="number">1</span>, y)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> y &lt; n<span class="number">-1</span> &#123;</span><br><span class="line">			dfs(x, y+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径-1"><a href="#不同路径-1" class="headerlink" title="不同路径||"></a>不同路径||</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>思路</strong></p>
<p>这道题大体思路和上面一题一样，具体说说怎么解决障碍物的问题</p>
<ol>
<li><p><strong>边缘障碍物</strong></p>
<p>边缘障碍物主要是指最上面一层和最左边一层的障碍物，只要中间有一个障碍物出现，后面的路径都为0，显而易见</p>
</li>
<li><p>中间障碍物</p>
<p>如果左边或者上面有一个为障碍物，则他的路径数就是没有障碍物的那一方的数字</p>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	m, n := <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">			obstacleGrid[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obstacleGrid[i][<span class="number">0</span>] = obstacleGrid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span> &#123;</span><br><span class="line">			obstacleGrid[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obstacleGrid[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">				obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<p>dp 表示拆分index次情况下的最大数</p>
<ul>
<li>i * (i - j) 表示不继续拆分的情况</li>
<li>i * dp[i-j] 表示继续拆分的情况，因为dp[i-j]是i-j情况下的拆分最大值，所以直接套用即可不用重新计算dp[i-j]的大小</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integerBreak</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt; n+<span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eK411o7QA/?vd_source=6fa0adb119deebe624c0a774c3f2cdf1">动态规划找到子状态之间的关系很重要！| LeetCode：96.不同的二叉搜索树_哔哩哔哩_bilibili</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i; j++ &#123;</span><br><span class="line">			dp[i] += dp[j<span class="number">-1</span>] * dp[i-j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><blockquote>
<p><strong>背包问题的变形</strong></p>
<ol>
<li>最多装 capacity，求<strong>方案数</strong>&#x2F;最大价值和</li>
<li>恰好装 capacity，求<strong>方案数</strong>&#x2F;最大价值和&#x2F;最小价值和</li>
<li>最少装 capacity，求<strong>方案数</strong>&#x2F;最小价值和</li>
</ol>
</blockquote>
<blockquote>
<p><strong>方案数：  dp[j]  +&#x3D; dp[j-nums[i]]</strong></p>
<p><strong>价值和： dp[j] &#x3D; max(dp[j],dp[j-value[i]]+value[i])</strong></p>
</blockquote>
<p>听说这个问题特别重要</p>
<blockquote>
<p> 小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 </p>
<p>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。</p>
</blockquote>
<ol>
<li><p>确定dp数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] 表示在[<span class="number">0</span>-i]中任意取物品，放进容量为j的背包中，最大的价值</span><br></pre></td></tr></table></figure>
</li>
<li><p>递推公式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不放物品  dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment">// 如果放物品    dp[i][j]= dp[i-1][j-w[i]] + v[i]   //如果放物品，则背包的容量变成了 j-w[i]，因此背包为j-w[i]时的最大价值为dp[i-1][j-w[i]]，加上当前物品的价值v[i]即为dp[i][j]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化dp数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][0] = 0 </span></span><br><span class="line"><span class="comment">// dp[0][j] = 如果背包容量大于dp[0]就为dp[0],否则为0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight 是物品的质量    capacity是背包的容量  ，不能把物品的质量当作背包的容量。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bags</span><span class="params">(value []<span class="type">int</span>, weight []<span class="type">int</span>, capacity <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(value))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, capacity+<span class="number">1</span>) <span class="comment">// 容量0也要计算</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= capacity; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> weight[<span class="number">0</span>] &lt;= i &#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = value[<span class="number">0</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">0</span> <span class="comment">// 初始化容量为0时的价值为0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先物品、后背包</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(value); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= capacity; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> weight[i] &gt; j &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(value)<span class="number">-1</span>][capacity]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	value := []<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	weight := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(bags(value, weight, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题的单数组求解"><a href="#背包问题的单数组求解" class="headerlink" title="背包问题的单数组求解"></a>背包问题的单数组求解</h2><p>只使用一个数组来求解背包问题</p>
<p>注意点</p>
<ul>
<li>dp[i]表示容量为i的背包装dp[i]的价值</li>
<li>基本的思路还是按照二维数组的解法来做的，就是代码呈现不一样</li>
<li>遍历顺序要倒序</li>
<li>只使用一个数组就表示当前数组要不断被覆盖</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_1_wei_bag_problem</span><span class="params">(weight, value []<span class="type">int</span>, bagWeight <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 定义 and 初始化</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>,bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 递推顺序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(weight) ; i++ &#123;</span><br><span class="line">		<span class="comment">// 这里必须倒序,区别二维,因为二维dp保存了i的状态</span></span><br><span class="line">		<span class="keyword">for</span> j:= bagWeight; j &gt;= weight[i] ; j-- &#123;</span><br><span class="line">			<span class="comment">// 递推公式</span></span><br><span class="line">			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(dp)</span></span><br><span class="line">	<span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>思路：</strong></p>
<blockquote>
<p>一看到这道题，其实想要用回溯来做，但是danshi</p>
</blockquote>
<p>动态规划的变迁</p>
<ul>
<li>背包的体积为sum &#x2F; 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<p>根据上面的变迁和之前的背包问题的基础，基本上就可以做出来了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	partSum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		partSum += nums[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> partSum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	partSum = partSum / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, partSum+<span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:= partSum ; j&gt;=nums[i]; j-- &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dp[partSum] == partSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h2><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>思路：</strong></p>
<p>可以将石头分为两堆，使得两堆石头的重量差最小</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	partSum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, stone := <span class="keyword">range</span> stones &#123;</span><br><span class="line">		partSum += stone</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(stones)</span><br><span class="line">	m := partSum / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := m; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> partSum - <span class="number">2</span>*dp[m]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p>思路：</p>
<p>理解这道题用了我很多的时间，感觉对背包问题的具体思路解决还是不太清楚</p>
<p>dp[i]  i 表示容量   dp[i]表示大小</p>
<p>同时一维数组的求法中是不断的叠加，这个要注意</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">funcfindTargetSumWays(nums []<span class="type">int</span>,target <span class="type">int</span>)<span class="type">int</span>&#123;</span><br><span class="line">	sum:=<span class="number">0</span> </span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span> ;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">		sum += nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> sum &lt; Abs(target) || (sum + target)%<span class="number">2</span>==<span class="number">1</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bag := (sum + target)/<span class="number">2</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>,bag+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> nums[i]&#123;</span><br><span class="line">		<span class="keyword">for</span> j:=bag;j&gt;=nums[i];j++&#123;</span><br><span class="line">			dp[j]+=dp[j-nums[i]]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dp[bag]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="零和一"><a href="#零和一" class="headerlink" title="零和一"></a>零和一</h2><p>昨天因为心烦意乱所以就写了一题，这道题就没写，因为看又有1又有0</p>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxForm</span><span class="params">(strs []<span class="type">string</span>, m, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        zeros := strings.Count(s, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        ones := <span class="built_in">len</span>(s) - zeros</span><br><span class="line">        <span class="keyword">for</span> j := m; j &gt;= zeros; j-- &#123;</span><br><span class="line">            <span class="keyword">for</span> k := n; k &gt;= ones; k-- &#123;</span><br><span class="line">                dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones]+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包基础"><a href="#完全背包基础" class="headerlink" title="完全背包基础"></a>完全背包基础</h2><p>跟0-1背包的区别就是，物品的数量没有了限制，比如说同样是一堆有价值有重量的石头，0-1背包中每个石头只能用一次，而完全背包中无限用</p>
<p>还有一个区别就是完全背包的遍历顺序可以颠倒，可以先遍历物品重量，再遍历价值，而0-1背包中只能先遍历价值再遍历重量</p>
<p>完全背包中的遍历顺序是正向的，因为之前讲过从前往后遍历会导致重复，而完全背包不怕重复，反而需要重复，因此正向</p>
<blockquote>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。</p>
<p>小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_CompletePack1</span><span class="params">(weight, value []<span class="type">int</span>, bagWeight <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就来做道题目吧</p>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换||"></a>零钱兑换||</h2><p>我现在做动态规划已经有种，明明不理解但是还是能莫名其妙搓出来的感觉了</p>
<p>真不爽。。。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">       <span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">          dp[j] += dp[j-coins[i]]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和Ⅳ"><a href="#组合总和Ⅳ" class="headerlink" title="组合总和Ⅳ"></a>组合总和Ⅳ</h2><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<ul>
<li><p><strong>组合数</strong></p>
<p>循环的时候，先物品再背包</p>
</li>
<li><p><strong>排列数</strong></p>
<p>循环的时候，先背包再物品</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, target+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j:= <span class="number">0</span> ;j&lt;=target;j++&#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span> ;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">			<span class="keyword">if</span> j&gt;=nums[i]&#123;</span><br><span class="line">				dp[j] += dp[j-nums[i]]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人建议再去看一下这两个视频</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1o8411j73x/">目标和</a> 来理解组合数的求法</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1V14y1n7B6/">组合总和</a> 来理解总共组合数和排列数的区别</p>
<h2 id="爬楼梯（进阶版）"><a href="#爬楼梯（进阶版）" class="headerlink" title="爬楼梯（进阶版）"></a>爬楼梯（进阶版）</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 </p>
<p>每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ </p>
<p>注意：给定 n 是一个正整数。</p>
<p>思路和上题差不多</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m,n  <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;n,&amp;m)</span><br><span class="line">    dp:=<span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;</span><br><span class="line">       <span class="keyword">for</span> j:=<span class="number">1</span>;j &lt;= m;j++&#123;</span><br><span class="line">          <span class="keyword">if</span> i-j&gt;=<span class="number">0</span>&#123;</span><br><span class="line">             dp[i]+= dp[i-j]</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(dp[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="零钱兑换-1"><a href="#零钱兑换-1" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">       dp[i] = math.MaxInt32</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">       <span class="keyword">for</span> i := coin; i &lt;= amount; i++ &#123;</span><br><span class="line">          dp[i] = min(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dp[amount] == math.MaxInt32 &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p> 思路和上面一题一言</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		dp[i] = i</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j*j &lt;= i; j++ &#123;</span><br><span class="line">			dp[i] = min(dp[i], dp[i-j*j]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p> 思路同上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">			<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(word) &amp;&amp; dp[i-<span class="built_in">len</span>(word)] &amp;&amp; s[i-<span class="built_in">len</span>(word):i] == word &#123;</span><br><span class="line">				dp[i] = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包递推公式-总结"><a href="#背包递推公式-总结" class="headerlink" title="背包递推公式(总结)"></a>背包递推公式(总结)</h2><blockquote>
<p>来源于代码随想录，感谢!!</p>
</blockquote>
<p>问能否能装满背包（或者最多装多少）：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">动态规划：416.分割等和子集(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">动态规划：1049.最后一块石头的重量 II(opens new window)</a></li>
</ul>
<p>问装满背包有几种方法：dp[j] +&#x3D; dp[j - nums[i]] ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518. 零钱兑换 II(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377.组合总和Ⅳ(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li>
</ul>
<p>问背包装满最大价值：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html">动态规划：474.一和零(opens new window)</a></li>
</ul>
<p>问装满背包所有物品的最小个数：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322.零钱兑换(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></li>
</ul>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍|"></a>打家劫舍|</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>记住她的前后关系就可以做了</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>) <span class="comment">// dp[i]表示偷到第i家能够偷得的最大金额</span></span><br><span class="line">	dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打家劫舍-1"><a href="#打家劫舍-1" class="headerlink" title="打家劫舍||"></a>打家劫舍||</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<p>这里多了一个环的特点</p>
<p>但是如果我们只考虑<strong>第一个元素</strong>或者只考虑<strong>最后一个元素</strong>就可以做了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    rob1 := nums[<span class="number">1</span>:]</span><br><span class="line">    rob2 := nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    value1 :=  robbed(rob1)</span><br><span class="line">    value2 :=  robbed(rob2)</span><br><span class="line">    <span class="keyword">if</span> value1 &gt; value2&#123;</span><br><span class="line">        <span class="keyword">return</span> value1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">robbed</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>) </span><br><span class="line">	dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打家劫舍-2"><a href="#打家劫舍-2" class="headerlink" title="打家劫舍|||"></a>打家劫舍|||</h2><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金</em></p>
<p>思路：</p>
<p>树形DP，dp[0]表示没有盗取的最高金额，dp[1]表示盗取了的最高金额</p>
<p>思路一羊，不过形式比较新颖</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := dfs(root)</span><br><span class="line">    <span class="keyword">return</span> max(res[<span class="number">0</span>],res[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode)</span></span>[]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> root ==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := dfs(root.Left)</span><br><span class="line">    right := dfs(root.Right)</span><br><span class="line"></span><br><span class="line">    selected:= root.Val + left[<span class="number">1</span>] + right[<span class="number">1</span>]</span><br><span class="line">    notSelected := max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + max(right[<span class="number">0</span>],right[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;selected,notSelected&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">		dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(dp)<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Echin-h</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">http://example.com/2024/05/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Echin の 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</a></div><div class="post_share"><div class="social-share" data-image="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/02/%E5%9F%BA%E6%9C%AC%E7%9A%84io%E6%8E%A5%E5%8F%A3/" title="基本的io接口"><img class="cover" src="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基本的io接口</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/07/%E5%AE%9A%E5%88%B6%E5%8C%96Zap/" title="定制化Zap"><img class="cover" src="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">定制化Zap</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/27/%E6%95%B0%E7%BB%84/" title="数组"><img class="cover" src="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-27</div><div class="title">数组</div></div></a></div><div><a href="/2023/12/30/%E9%93%BE%E8%A1%A8/" title="链表"><img class="cover" src="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">链表</div></div></a></div><div><a href="/2023/12/30/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/" title="设计链表"><img class="cover" src="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">设计链表</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E5%9F%83%E7%BD%97%E8%8A%92%E9%98%BF%E8%80%81%E5%B8%88.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Echin-h</div><div class="author-info__description">keep learning</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">115</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Echin-h" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://mail.qq.com/cgi-bin/frame_html?sid=vYYzrbDEaqDZEhl8&amp;r=0505616c4ef48760cb44f616432dfbd8&amp;lang=zh" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">love is accumulated, not love, too.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.2.</span> <span class="toc-text">爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E4%BC%9A%E7%94%A8%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.3.</span> <span class="toc-text">使用最小会用爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.</span> <span class="toc-text">不同路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-1"><span class="toc-number">1.5.</span> <span class="toc-text">不同路径||</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">1.6.</span> <span class="toc-text">整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.7.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8D%95%E6%95%B0%E7%BB%84%E6%B1%82%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">背包问题的单数组求解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">1.10.</span> <span class="toc-text">分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII"><span class="toc-number">1.11.</span> <span class="toc-text">最后一块石头的重量II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">1.12.</span> <span class="toc-text">目标和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E5%92%8C%E4%B8%80"><span class="toc-number">1.13.</span> <span class="toc-text">零和一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E5%9F%BA%E7%A1%80"><span class="toc-number">1.14.</span> <span class="toc-text">完全背包基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">1.15.</span> <span class="toc-text">零钱兑换||</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3"><span class="toc-number">1.16.</span> <span class="toc-text">组合总和Ⅳ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E8%BF%9B%E9%98%B6%E7%89%88%EF%BC%89"><span class="toc-number">1.17.</span> <span class="toc-text">爬楼梯（进阶版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-1"><span class="toc-number">1.18.</span> <span class="toc-text">零钱兑换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">1.19.</span> <span class="toc-text">完全平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">1.20.</span> <span class="toc-text">单词拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F-%E6%80%BB%E7%BB%93"><span class="toc-number">1.21.</span> <span class="toc-text">背包递推公式(总结)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">1.22.</span> <span class="toc-text">打家劫舍|</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-1"><span class="toc-number">1.23.</span> <span class="toc-text">打家劫舍||</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-2"><span class="toc-number">1.24.</span> <span class="toc-text">打家劫舍|||</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">1.25.</span> <span class="toc-text">买卖股票的最佳时机</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/27/%E5%88%9D%E8%AF%95JS/" title="初试JS">初试JS</a><time datetime="2024-05-27T08:08:01.000Z" title="发表于 2024-05-27 16:08:01">2024-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/26/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E8%AE%B0/" title="随便记记">随便记记</a><time datetime="2024-05-26T13:24:04.000Z" title="发表于 2024-05-26 21:24:04">2024-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/%E6%88%91%E7%88%B1%E8%AE%B0%E5%8D%95%E8%AF%8D/" title="我爱记单词">我爱记单词</a><time datetime="2024-05-23T09:15:41.000Z" title="发表于 2024-05-23 17:15:41">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/20/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" title="装饰模式">装饰模式</a><time datetime="2024-05-20T05:44:45.000Z" title="发表于 2024-05-20 13:44:45">2024-05-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/18/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/" title="个人简历">个人简历</a><time datetime="2024-05-18T14:42:35.000Z" title="发表于 2024-05-18 22:42:35">2024-05-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://echin-h.oss-cn-hangzhou.aliyuncs.com/img/%E9%BB%91%E8%89%B2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Echin-h</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">today is a beautiful day</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>